% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Bliss_Simulated_Annealing.R
\name{Bliss_Simulated_Annealing}
\alias{Bliss_Simulated_Annealing}
\title{Bliss_Simulated_Annealing}
\usage{
Bliss_Simulated_Annealing(beta_sample, normalization_values, param,
  progress = FALSE)
}
\arguments{
\item{beta_sample}{a matrix. Each row is a coefficient function computed from the
posterior sample.}

\item{normalization_values}{a matrix given by the function "Bliss_Gibbs_Sampler". XXXXXXX}

\item{param}{a list containing:
\describe{
\item{grid}{a numerical vector, the observation time points.}
\item{burnin}{an integer, the number of iterations to drop from the Gibbs
      sample. (optional)}
\item{iter}{an integer, the number of iteration of the Gibbs Sampler algorithm.}
\item{iter_sann}{an integer, the number of iteration of the Simulated
      Annealing algorithm. (optional)} XXXXXXX
\item{Temp_init}{a non negative value, the initial temperature for the
      cooling function of the Simulated Annealing. (optional)}
\item{k_max}{an integer, the maximum number of intervals. (optional)} XXXXXXX
\item{l_max_sann}{an integer, the maximum value for the parameter l. (optional)} XXXXXXX
\item{basis}{a character vectors, used to compute the coefficient function,
      see the function beta_build. (optional)} XXXXXXX
\item{K}{a vector of integers, corresponding to the numbers of intervals for
      each covariate.}
}}

\item{progress}{a logical value. If TRUE, the algorithm progress is displayed.
(optional)}
}
\value{
a list containing:
\describe{
 \item{Bliss_estimate}{a numerical vector, corresponding to the Bliss estimate
       of the coefficient function.}
 \item{Smooth_estimate}{a numerical vector, which is the posterior expectation
       of beta(t), for each t in the grid ot time points.}
 \item{trace}{Each row is an iteration of the Simulated Annealing algorithm.}
 \item{argmin}{an integer, which is the index of the iteration minimizing
       the Bliss loss.}
}
}
\description{
A Simulated Annealing algorithm to determine the Bliss estimate
             (for only functional covariate), i.e. the minimum of the
             posterior expectation of the Bliss loss.
}
\examples{
data(data1)
data(param1)
param1$grids<-data1$grids
# result of res_bliss1<-fit_Bliss(data=data1,param=param1)
data(res_bliss1)
beta_sample <- compute_beta_sample(posterior_sample=res_bliss1$posterior_sample,
                                   param=param1,Q=2)
param_test<-list(grid=param1$grids[[1]],iter=1e4,K=2)
test<-Bliss_Simulated_Annealing(beta_sample[[1]],
                 res_bliss1$posterior_sample$param$normalization_values[[1]],
                 param=param_test)
plot(param_test$grid,test$Bliss_estimate,type="l")
lines(param_test$grid,test$Smooth_estimate,lty=2)
}
